#version 460
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage : require
struct Node {
    uint8_t _padding1;
    uint8_t freemask;
    uint16_t _padding2;
    uint children;
    uint16_t data[8];
};

struct Ray {
    vec3 origin;
    vec3 dir;
};
struct Box {
    vec3 origin;
    float extent;
};
struct Sunlight {
    vec3 color;
    float padding1;
    vec3 dir;
    float padding2;
};
uint MaskLocationNthOne(uint mask, uint location) {
    return bitCount(mask & ((1 << location) - 1));
}


layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (constant_id = 0) const uint MAX_ITERATION_VALUE = 100;
const Box GlobalBoundingBox = { vec3(0,0,0), 512 };
layout(rgba32f, set = 2, binding = 0) uniform image2D imgOutput;

layout(push_constant) uniform constants
{
	uvec2 extents;
    float aspectRatio;
} PushConstants;
layout(set = 0, binding = 0) uniform u_Camera {
    mat3 rotation;
    vec3 position;
    float tanHalfFov;
} Camera;/*
layout(set = 0, binding = 1) uniform Lights {
    Sunlight Lights_Sunlight;
};*/
layout(set = 1, binding = 0) readonly buffer Chunk {
    Node Chunk_Nodes[];
};
struct Material {
    float scale;
    uint16_t diffuse;
    uint16_t normal;
    float _reserved1;
    float _reserved2;
};
struct ColoredMaterial {
    float scale;
    uint16_t diffuse;
    uint16_t normal;
    float _reserved1;
    float _reserved2;
    vec4 palette[128];
};
layout(set = 1, binding = 1) readonly buffer Materials {
    Material u_RegularMaterials[];
};
layout(set = 1, binding = 2) readonly buffer ColoredMaterials {
    ColoredMaterial u_ColoredMaterials[];
};
layout(set = 1, binding = 3) uniform sampler2DArray TextureRepoSampler;




Ray GenerateRay() {
    uvec2 pixelRaster = gl_GlobalInvocationID.xy;

    vec2 pixelNDC = vec2(pixelRaster) / vec2(PushConstants.extents);
    vec2 pixelCamera = 2 * pixelNDC - 1;
    pixelCamera.y *= -1;
    pixelCamera.x *= PushConstants.aspectRatio;
    pixelCamera *= Camera.tanHalfFov;

    vec3 pixelCameraWorld = Camera.rotation * vec3(pixelCamera, -1);
    Ray ray;
    ray.origin = Camera.position;
    ray.dir = normalize(pixelCameraWorld);
    return ray;
}

vec2 IntersectAABB(vec3 origin, vec3 dir, Box box) {
    vec3 box_min = box.origin;
    vec3 box_max = box_min + box.extent;
    vec3 tMin = (box_min - origin) / dir;
    vec3 tMax = (box_max - origin) / dir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float t_min = max(max(t1.x, t1.y), t1.z);
    float t_max = min(min(t2.x, t2.y), t2.z);
    return vec2(t_min, t_max);
}
bool ContainsAABB(vec3 point, Box box) {
    vec3 min = box.origin;
    vec3 max = min + box.extent;

    vec3 s = step(min, point) - step(max, point);
    bvec3 bs = bvec3(s);
    return all(bs);
}
vec3 CubedNormalize(vec3 dir) {
    vec3 dir_abs = abs(dir);
    float max_element = max(dir_abs.x, max(dir_abs.y, dir_abs.z));
    return -sign(dir) * step(max_element, dir_abs);
}
uint MaterialAtPosition(inout Box box, vec3 position) {
    uint node_index = 0; // Assume root node

    while(true) {
        // start
        // Calculate new box location
        box.extent = box.extent / 2;
        vec3 box_midpoint = box.origin + box.extent;
        vec3 s = step(box_midpoint, position);
        box.origin = box.origin + s * box.extent;


        uint child_index = uint(dot(s, vec3(4,2,1)));
        uint freemask = uint(Chunk_Nodes[node_index].freemask);
        if ((freemask & (1 << child_index)) == 0) {
            // is a leaf node
            return uint(Chunk_Nodes[node_index].data[child_index]);
        } else {
            // has children
            uint child_offset = MaskLocationNthOne(freemask, child_index);
            node_index = Chunk_Nodes[node_index].children + child_offset;
        }
    }
}

uint RayMarch(Box initial_box, Ray ray, out vec3 hitpoint, out Box hitbox, out uint counter, float initialDistance) {
    hitbox = initial_box;
    vec3 entry_point = ray.origin + initialDistance * ray.dir;
    vec3 test_point = entry_point;
    uint material_id = 0;

    for(
    counter = 0;
    counter < MAX_ITERATION_VALUE && ContainsAABB(test_point, GlobalBoundingBox);
    counter++) {
        // TODO: change this so that entry point doesn't get too big
        hitbox = initial_box;
        material_id = MaterialAtPosition(hitbox, test_point);
        if (material_id > 0) {
            // Hit some materials
            break;
        }
        // calculate the next t_min
        vec2 new_intersection = IntersectAABB(entry_point, ray.dir, hitbox);

        entry_point = entry_point + ray.dir * new_intersection.y;
        test_point = entry_point + sign(ray.dir) * hitbox.extent * 0.001;
    }
    hitpoint = entry_point;
    return material_id;
}

#define DEBUG_RENDERING

void main2() {
    Ray ray = GenerateRay();

    float depth;
    vec3 hitpoint;
    Box hitbox;
    uint iteration_times;
    uint voxel_id = RayMarch(GlobalBoundingBox, ray, hitpoint, hitbox, iteration_times, 0);
    float iteration = float(iteration_times) / float(MAX_ITERATION_VALUE); // 0 to 1
    #ifdef DEBUG_RENDERING
    vec4 f_color = vec4(iteration, iteration, iteration, 1.0);
    #else
    vec3 normal = CubedNormalize(hitpoint - (hitbox.origin + hitbox.extent/2));
    vec2 texcoords = vec2(
        dot(vec3(hitpoint.z, hitpoint.x, -hitpoint.x), normal),
        dot(-sign(normal) * vec3(hitpoint.y, hitpoint.z, hitpoint.y), normal)
    );

    vec4 output_color;
    uint diffuseTextureId;
    float scale = 1.0;


    if (voxel_id == 0) {
        //f_color = vec4(0.0, 1.0, 0.0, 1.0);
        //return;
        return;
    } else if ((voxel_id & 0x8000) == 0) {
        uint materialId = voxel_id - 1;
        diffuseTextureId = uint(u_RegularMaterials[materialId].diffuse);
        output_color = vec4(1, 1, 1, 1);
        scale = u_RegularMaterials[materialId].scale;
    } else {
        uint materialId = voxel_id & 0xff; // lower 8 bits
        uint colorId = (voxel_id >> 8) & 0x7f;
        diffuseTextureId = uint(u_ColoredMaterials[materialId].diffuse);
        output_color = u_ColoredMaterials[materialId].palette[colorId];
        scale = u_ColoredMaterials[materialId].scale;
    }

    if (diffuseTextureId != 0xffffffff) {
        output_color *= texture(
            TextureRepoSampler,
            vec3(
                texcoords * scale,
                diffuseTextureId
            )
        );
    }
    float sunLightFactor =min(1.0, max(0.3, dot(normal, Lights_Sunlight.dir)));



    vec4 f_color = output_color * vec4(sunLightFactor, sunLightFactor, sunLightFactor, 1.0);
    #endif
    imageStore(imgOutput, ivec2(gl_GlobalInvocationID.xy), f_color);
}


struct ChildDescriptor {
    uint children;
    uint freemask;
};
struct StackItem {
    uint parent;
    float t_max;
};

#define CAST_STACK_DEPTH 23
#define MAX_RAYCAST_ITERATIONS  100
void main() {
    vec4 color = vec4(0.0, 0.0 ,0.0 ,1.0);
    StackItem stack[CAST_STACK_DEPTH + 1];


    Ray ray = GenerateRay();
    ray.dir *= 100;
    const float epsilon = exp2(-CAST_STACK_DEPTH);
    uint iter = 0;


    // Get rid of small ray direction components to avoid division by zero
    // if (abs(ray.dir.x) < epsilon) ray.dir.x = copysign(epsilon, ray.dir.x);
    // if (fabsf(ray.dir.y) < epsilon) ray.dir.y = copysignf(epsilon, ray.dir.y);
    // if (fabsf(ray.dir.z) < epsilon) ray.dir.z = copysignf(epsilon, ray.dir.z);


    vec3 t_coef = 1.0 / -abs(ray.dir);
    vec3 t_bias = t_coef * ray.origin;


    // Select octant mask to mirror the coordinate system so
    // that ray direction is negative along each axis.

    int octant_mask = 0; // This is different from the original esvo because our coordinate system was flipped.
    if (ray.dir.x > 0.0f) octant_mask ^= 4, t_bias.x = 3.0f * t_coef.x - t_bias.x;
    if (ray.dir.y > 0.0f) octant_mask ^= 2, t_bias.y = 3.0f * t_coef.y - t_bias.y;
    if (ray.dir.z > 0.0f) octant_mask ^= 1, t_bias.z = 3.0f * t_coef.z - t_bias.z;


    // Initialize the active span of t-values.

    float t_min = max(max(2.0f * t_coef.x - t_bias.x, 2.0f * t_coef.y - t_bias.y), 2.0f * t_coef.z - t_bias.z);
    float t_max = min(min(t_coef.x - t_bias.x, t_coef.y - t_bias.y), t_coef.z - t_bias.z);
    float h = t_max;
    t_min = max(t_min, 0.0f);
    t_max = min(t_max, 1.0f);
    if (t_min <= t_max) {
        color.r = 1.0;
    }
    
    // Initialize the current voxel to the first child of the root.

    uint   parent           = 0;
    ChildDescriptor   child_descriptor;
    child_descriptor.children = 0;
    child_descriptor.freemask = 0; // invalid until fetched
    uint    idx              = 0;
    vec3 pos              = vec3(1.0f, 1.0f, 1.0f);
    uint    scale            = CAST_STACK_DEPTH - 1;
    float  scale_exp2       = 0.5f; // exp2f(scale - s_max)

    if (1.5f * t_coef.x - t_bias.x > t_min) idx ^= 4, pos.x = 1.5f;
    if (1.5f * t_coef.y - t_bias.y > t_min) idx ^= 2, pos.y = 1.5f;
    if (1.5f * t_coef.z - t_bias.z > t_min) idx ^= 1, pos.z = 1.5f;

    // Traverse voxels along the ray as long as the current voxel
    // stays within the octree.
    while(scale < CAST_STACK_DEPTH){
        iter++;
        if (iter > MAX_RAYCAST_ITERATIONS)
            break;
        // Fetch child descriptor unless it is already valid.
        if (child_descriptor.children == 0) {
            child_descriptor.freemask = uint(Chunk_Nodes[parent].freemask);
            child_descriptor.children = Chunk_Nodes[parent].children;
        }

        

        // Determine maximum t-value of the cube by evaluating
        // tx(), ty(), and tz() at its corner.

        vec3 t_corner = pos * t_coef - t_bias;
        float tc_max = min(min(t_corner.x, t_corner.y), t_corner.z);

        // Process voxel if the corresponding bit in valid mask is set
        // and the active t-span is non-empty.
        uint child_shift = idx ^ octant_mask;
        if (
            (
                ((child_descriptor.freemask & (1 << child_shift)) != 0) ||
                (uint(Chunk_Nodes[parent].data[child_shift]) != 0)
            ) &&
            (t_min <= t_max)
        ) {
            // Terminate if the voxel is small enough.
            // TODO


            // INTERSECT
            // Intersect active t-span with the cube and evaluate
            // tx(), ty(), and tz() at the center of the voxel.
            float tv_max = min(t_max, tc_max);
            float half_length = scale_exp2 * 0.5f;
            vec3 t_center = half_length * t_coef + t_corner;

            if (t_min <= tv_max) {
                // Terminate if the corresponding bit in the non-leaf mask is not set.
                if ((child_descriptor.freemask & (1 << child_shift)) == 0)
                    break;


                // PUSH
                // Write current parent to the stack.

                if (tc_max < h)
                {
                    // stack.write(scale, parent, t_max);
                    StackItem item;
                    item.parent = parent;
                    item.t_max = t_max;
                    stack[scale] = item;
                }
                h = tc_max;

                // Find child descriptor corresponding to the current voxel.
                parent = child_descriptor.children + MaskLocationNthOne(child_descriptor.freemask, child_shift);


                // Select child voxel that the ray enters first.

                idx = 0;
                scale--;
                scale_exp2 = half_length;

                if (t_center.x > t_min) idx ^= 4, pos.x += scale_exp2;
                if (t_center.y > t_min) idx ^= 2, pos.y += scale_exp2;
                if (t_center.z > t_min) idx ^= 1, pos.z += scale_exp2;

                // Update active t-span and invalidate cached child descriptor.

                t_max = tv_max;
                child_descriptor.children = 0;
                continue;
            }
        }

        // ADVANCE
        // Step along the ray

        uint step_mask = 0;
        if (t_corner.x <= tc_max) step_mask ^= 4, pos.x -= scale_exp2;
        if (t_corner.y <= tc_max) step_mask ^= 2, pos.y -= scale_exp2;
        if (t_corner.z <= tc_max) step_mask ^= 1, pos.z -= scale_exp2;

        // Update active t-span and flip bits of the child slot index.

        t_min = tc_max;
        idx ^= step_mask;


        // Proceed with pop if the bit flips disagree with the ray direction.
        if ((idx & step_mask) != 0) {
            // POP
            // Find the highest differing bit between the two positions.
            uint differing_bits = 0;
            if ((step_mask & 4) != 0) differing_bits |= floatBitsToUint(pos.x) ^ floatBitsToUint(pos.x + scale_exp2);
            if ((step_mask & 2) != 0) differing_bits |= floatBitsToUint(pos.y) ^ floatBitsToUint(pos.y + scale_exp2);
            if ((step_mask & 1) != 0) differing_bits |= floatBitsToUint(pos.z) ^ floatBitsToUint(pos.z + scale_exp2);
            scale = (floatBitsToUint(float(differing_bits)) >> 23) - 127; // position of the highest bit
            scale_exp2 = uintBitsToFloat((scale - CAST_STACK_DEPTH + 127) << 23); // exp2f(scale - s_max)

            // Restore parent voxel from the stack.

            StackItem stackVal = stack[scale];
            parent = stackVal.parent;
            t_max = stackVal.t_max;

            uint shx = floatBitsToUint(pos.x) >> scale;
            uint shy = floatBitsToUint(pos.y) >> scale;
            uint shz = floatBitsToUint(pos.z) >> scale;
            pos.x = uintBitsToFloat(shx << scale);
            pos.y = uintBitsToFloat(shy << scale);
            pos.z = uintBitsToFloat(shz << scale);
            idx  = (shz & 1) | ((shy & 1) << 1) | ((shx & 1) << 2);

            // Prevent same parent from being stored again and invalidate cached child descriptor.

            h = 0.0f;
            child_descriptor.children = 0;
        }
    }

    // Indicate miss if we are outside the octree.
    if (scale >= CAST_STACK_DEPTH || iter > MAX_RAYCAST_ITERATIONS) {
        t_min = 2.0f;
    }
    // Undo mirroring of the coordinate system.

    if ((octant_mask & 4) == 0) pos.x = 3.0f - scale_exp2 - pos.x;
    if ((octant_mask & 2) == 0) pos.y = 3.0f - scale_exp2 - pos.y;
    if ((octant_mask & 1) == 0) pos.z = 3.0f - scale_exp2 - pos.z;

    // Output results.
/*
    res.t = t_min;
    res.iter = iter;
    res.pos.x = fminf(fmaxf(ray.orig.x + t_min * ray.dir.x, pos.x + epsilon), pos.x + scale_exp2 - epsilon);
    res.pos.y = fminf(fmaxf(ray.orig.y + t_min * ray.dir.y, pos.y + epsilon), pos.y + scale_exp2 - epsilon);
    res.pos.z = fminf(fmaxf(ray.orig.z + t_min * ray.dir.z, pos.z + epsilon), pos.z + scale_exp2 - epsilon);
    res.node = parent;
    res.childIdx = idx ^ octant_mask ^ 7;
    res.stackPtr = scale;
*/

    if (t_min > 1.0) {
        // No hit
    } else {
        float v = float(iter) / 100;
        color.r = v;
        color.g = v;
        color.b = v;
        color.a = 1;
    }
    
    imageStore(imgOutput, ivec2(gl_GlobalInvocationID.xy), color);
}
