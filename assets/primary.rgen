#version 460
#extension GL_EXT_ray_tracing : require

struct RayPayload {
    vec3 color;
};

layout(set = 0, binding = 0) uniform writeonly image2D u_imgOutput;
layout(set = 0, binding = 1) uniform accelerationStructureEXT accelerationStructure;
layout(push_constant) uniform constants
{
    vec4 camera_view_col0_near;
    vec4 camera_view_col1_far;
    vec4 camera_view_col2;
    vec4 camera_position_tan_half_fov;
} PushConstants;

layout(location = 0) rayPayloadEXT RayPayload primaryRayPayload;

void main() {
    const vec2 pixelNDC = (vec2(gl_LaunchIDEXT.xy) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);

    vec2 pixelCamera = 2 * pixelNDC - 1;
    pixelCamera.y *= -1;
    pixelCamera.x *= float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);
    pixelCamera *= PushConstants.camera_position_tan_half_fov.w;

    const mat3 rotationMatrix = mat3(PushConstants.camera_view_col0_near.xyz, PushConstants.camera_view_col1_far.xyz, PushConstants.camera_view_col2.xyz);

    const vec3 pixelCameraWorld =  rotationMatrix * vec3(pixelCamera, -1);

    traceRayEXT(
        accelerationStructure, // acceleration structure
        gl_RayFlagsOpaqueEXT,       // rayFlags
        0xFF,           // cullMask
        0,              // sbtRecordOffset, or the ray index
        1,              // sbtRecordStride, or the total number of ray types
        0,              // missIndex
        PushConstants.camera_position_tan_half_fov.xyz,     // ray origin
        PushConstants.camera_view_col0_near.w,           // ray min range
        pixelCameraWorld,  // ray direction
        PushConstants.camera_view_col1_far.w,           // ray max range
        0               // payload (location = 0)
    );
    imageStore(u_imgOutput, ivec2(gl_LaunchIDEXT.xy), vec4(primaryRayPayload.color, 1.0));
}
