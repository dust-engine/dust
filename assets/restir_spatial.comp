#version 460
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

float interleaved_gradient_noise(vec2 px) {
    return fract (52.9829189 * fract(0.06711056f * px.x + 0.00583715f * px.y));
}
float interleaved_gradient_noise_animated(vec2 px, uint frame)
{
    frame = frame % 64; // need to periodically reset frame to avoid numerical issues
    px = px + 5.588238 * float(frame);
    return interleaved_gradient_noise(px);
}
layout(set = 0, binding = 0, rgba32f) uniform image2D u_illuminance;
layout(push_constant) uniform PushConstants {
    uint rand;
    uint frameIndex;
} pushConstants;




uint hash1(uint x) {
	x += (x << 10u);
	x ^= (x >>  6u);
	x += (x <<  3u);
	x ^= (x >> 11u);
	x += (x << 15u);
	return x;
}


uint hash1_mut(inout uint h) {
    uint res = h;
    h = hash1(h);
    return res;
}


float uint_to_u01_float(uint h) {
	const uint mantissaMask = 0x007FFFFFu;
	const uint one = 0x3F800000u;

	h &= mantissaMask;
	h |= one;

	float  r2 = uintBitsToFloat( h );
	return r2 - 1.0;
}



struct Sample {
    vec3 visible_point_normal; // The normal at the primary ray hit point in world space
    uint voxel_id;
    vec3 outgoing_radiance; // Outgoing radiance at the sample point in XYZ color space
    uint reserved;
};

struct Reservoir {
    Sample current_sample;      // z
    float total_weight; // w
    uint sample_count; // M
};

void ReservoirUpdate(inout Reservoir self, Sample new_sample, float sample_weight, inout uint rng) {
    self.total_weight += sample_weight;
    self.sample_count += 1;
    const float dart = uint_to_u01_float(hash1_mut(rng));

    if ((self.sample_count == 1) || (dart < sample_weight / self.total_weight)) {
        self.current_sample = new_sample;
    }
}

// Adds `newReservoir` into `reservoir`, returns true if the new reservoir's sample was selected.
// This function assumes the newReservoir has been normalized, so its weightSum means "1/g * 1/M * \sum{g/p}"
// and the targetPdf is a conversion factor from the newReservoir's space to the reservoir's space (integrand).
void ReservoirMerge(inout Reservoir self, Reservoir other, float target_pdf, inout uint rng) {
    uint total_sample_count = self.sample_count + other.sample_count;
    ReservoirUpdate(self, other.current_sample, target_pdf * other.total_weight * other.sample_count, rng);
    self.sample_count = total_sample_count;
}

layout(set = 0, binding = 1, std430) buffer ReservoirData {
    Reservoir reservoirs[];
} s_reservoirs_in;


#define M_PI 3.14159265358979323846264338327950288
#define M_TAU 6.28318530717958647692528676655900577
#define GOLDEN_ANGLE 2.39996323; 

uint hash_combine2(uint x, uint y) {
    const uint M = 1664525u, C = 1013904223u;
    uint seed = (x * M + y + C) * M;

    // Tempering (from Matsumoto)
    seed ^= (seed >> 11u);
    seed ^= (seed << 7u) & 0x9d2c5680u;
    seed ^= (seed << 15u) & 0xefc60000u;
    seed ^= (seed >> 18u);
    return seed;
}

uint hash2(uvec2 v) {
	return hash_combine2(v.x, hash1(v.y));
}

uint hash3(uvec3 v) {
	return hash_combine2(v.x, hash2(v.yz));
}

float sample_target_pdf(Sample s) {
    return s.outgoing_radiance.y;
}



void main() {
    vec4 illuminance = imageLoad(u_illuminance, ivec2(gl_GlobalInvocationID.xy));
    const float ang_off = (pushConstants.frameIndex * 23) % 32 * M_TAU + interleaved_gradient_noise(gl_GlobalInvocationID.xy) * M_PI;

    const float sample_count = 0;
    uint rng = hash3(uvec3(gl_GlobalInvocationID.xy, pushConstants.rand));
    float sample_radius_offset = uint_to_u01_float(hash1_mut(rng));
    const vec2 dist_to_edge_xy = min(vec2(gl_GlobalInvocationID.xy), imageSize(u_illuminance).xy - gl_GlobalInvocationID.xy);
    vec2 kernel_radius = min(vec2(8.0), dist_to_edge_xy);


    Reservoir reservoir_center = s_reservoirs_in.reservoirs[gl_GlobalInvocationID.x * imageSize(u_illuminance).y + gl_GlobalInvocationID.y];

    // normalize
        
    for (int i = 0; i < sample_count; i++) {
        float ang = (i + ang_off) * GOLDEN_ANGLE;
        vec2 radius = (pow(float(float(i) + sample_radius_offset) / sample_count, 0.5) * kernel_radius);
        ivec2 rpx_offset = ivec2(vec2(cos(ang), sin(ang)) * radius);
        
        uvec2 sample_location = gl_GlobalInvocationID.xy + rpx_offset;

        Reservoir reservoir_sample = s_reservoirs_in.reservoirs[sample_location.x * imageSize(u_illuminance).y + sample_location.y];

        float jacobian = 1.0;

        // Normalize new reservoir.
        uint original_sample_count = reservoir_center.sample_count;
        ReservoirUpdate(reservoir_center, reservoir_sample.current_sample, reservoir_sample.total_weight, rng);
        reservoir_center.sample_count = original_sample_count + reservoir_sample.sample_count;
    }

    
    float W = reservoir_center.total_weight / max(1e-8, reservoir_center.sample_count  * sample_target_pdf(reservoir_center.current_sample));
    vec3 resampled_radiance = W * reservoir_center.current_sample.outgoing_radiance;

    imageStore(u_illuminance, ivec2(gl_GlobalInvocationID.xy), vec4(illuminance.xyz + resampled_radiance, 1.0));
    //s_reservoirs_in.reservoirs[gl_GlobalInvocationID.x * imageSize(u_illuminance).y + gl_GlobalInvocationID.y] = reservoir_center;
}
